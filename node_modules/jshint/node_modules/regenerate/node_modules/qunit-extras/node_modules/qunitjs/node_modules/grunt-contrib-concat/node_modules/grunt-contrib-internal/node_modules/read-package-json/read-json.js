// vim: set softtabstop=16 shiftwidth=16:

try {
                var fs = require("graceful-fs")
} catch (er) {
                var fs = require("fs")
}


module.exports = readJson

var LRU = require("lru-cache")
readJson.cache = new LRU({max: 1000})
var path = require("path")
var glob = require("glob")
var normalizeData = require("normalize-package-data")

// put more stuff on here to customize.
readJson.extraSet = [
                gypfile,
                serverjs,
                scriptpath,
                authors,
                readme,
                mans,
                bins,
                githead
]

var typoWarned = {}


function readJson (file, log_, strict_, cb_) {
                var log, strict, cb
                for (var i = 1; i < arguments.length - 1; i++) {
                                if (typeof arguments[i] === 'boolean')
                                                strict = arguments[i]
                                else if (typeof arguments[i] === 'function')
                                                log = arguments[i]
                }
                if (!log) log = function () {};
                cb = arguments[ arguments.length - 1 ]

                var c = readJson.cache.get(file)
                if (c) {
                                cb = cb.bind(null, null, c)
                                return process.nextTick(cb);
                }
                cb = (function (orig) { return function (er, data) {
                                if (data) readJson.cache.set(file, data);
                                return orig(er, data)
                } })(cb)
                readJson_(file, log, strict, cb)
}


function readJson_ (file, log, strict, cb) {
                fs.readFile(file, "utf8", function (er, d) {
                                parseJson(file, er, d, log, strict, cb)
                })
}


function stripBOM(content) {
                // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
                // because the buffer-to-string conversion in `fs.readFileSync()`
                // translates it to FEFF, the UTF-16 BOM.
                if (content.charCodeAt(0) === 0xFEFF) {
                                content = content.slice(1);
                }
                return content;
}


function parseJson (file, er, d, log, strict, cb) {
                if (er && er.code === "ENOENT") {
                                indexjs(file, er, log, strict, cb)
                                return
                }
                if (er) return cb(er);
                try {
                                d = JSON.parse(stripBOM(d))
                } catch (er) {
                                d = parseIndex(d)
                                if (!d) return cb(parseError(er, file));
                }
                extras(file, d, log, strict, cb)
}


function indexjs (file, er, log, strict, cb) {
                if (path.basename(file) === "index.js") {
                                return cb(er);
                }
                var index = path.resolve(path.dirname(file), "index.js")
                fs.readFile(index, "utf8", function (er2, d) {
                                if (er2) return cb(er);
                                d = parseIndex(d)
                                if (!d) return cb(er);
                                extras(file, d, log, strict, cb)
                })
}


readJson.extras = extras
function extras (file, data, log_, strict_, cb_) {
                var log, strict, cb
                for (var i = 2; i < arguments.length - 1; i++) {
                                if (typeof arguments[i] === 'boolean')
                                                strict = arguments[i]
                                else if (typeof arguments[i] === 'function')
                                                log = arguments[i]
                }
                if (!log) log = function () {};
                cb = arguments[i]
                var set = readJson.extraSet
                var n = set.length
                var errState = null
                set.forEach(function (fn) {
                                fn(file, data, then)
                })
                function then(er) {
                                if (errState) return;
                                if (er) return cb(errState = er);
                                if (--n > 0) return;
                                final(file, data, log, strict, cb);
                }
}

function scriptpath (file, data, cb) {
                if (!data.scripts) return cb(null, data);
                var k = Object.keys(data.scripts)
                k.forEach(scriptpath_, data.scripts)
                cb(null, data);
}
function scriptpath_(key) {
                s = this[key]
                // This is never allowed, and only causes problems
                if (typeof s !== 'string')
                                return delete this[key]
                var spre = /^(\.[\/\\])?node_modules[\/\\].bin[\\\/]/
                if (s.match(spre))
                              
var tap = require("tap")
  , test = tap.test
  , plan = tap.plan
  , math

test("load sut", function (t) {
  math = require("../lib/math")
  t.ok(math, "object loaded")
  t.end()
})

test("validate constants", function (t) {
  t.equal(math.LN10, 2.302585092994046, "ln 10")
  t.equal(math.PI, 3.141592653589793, "pi")
  t.equal(math.E, 2.718281828459045, "e")
  t.equal(math.LOG10E, 0.4342944819032518, "log 10 e")
  t.equal(math.SQRT2, 1.4142135623730951, "sqrt 2")
  t.equal(math.SQRT1_2, 0.7071067811865476, "sqrt 1/2")
  t.equal(math.LN2, 0.6931471805599453, "ln2")
  t.end()
})

test("using this", function (t) {
  // this also works.
  this.equal(t, this, "call in scope of test obj")
  this.end()
})

// test setTimeout, just a trivial example.
test("setTimeout", function (t) {
  var start = Date.now()
  setTimeout(function () {
    t.ok(Date.now() >= start + 50, "timeout fired after delay")
    t.end()
  }, 50)
})

// another way to do the same, using a plan.
// this is more robust, but annoying when you have a long list
// of tests for something.  For async stuff, it's generally better,
// since there's a higher risk of the control flowing off to lala land.
test("setTimeout planned", function (t) {
  t.plan(1)
  var start = Date.now()
  setTimeout(function () {
    t.ok(Date.now() >= start + 50, "timeout fired after delay")
  }, 50)
})

// plans also are good for cases where things may fire in a non-deterministic
// order, since it won't be as obvious when everything is done.
test("setTimeout parallel", function